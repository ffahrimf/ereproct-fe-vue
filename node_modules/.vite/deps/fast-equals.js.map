{
  "version": 3,
  "sources": ["../../fast-equals/src/utils.ts", "../../fast-equals/src/equals.ts", "../../fast-equals/src/comparator.ts", "../../fast-equals/src/index.ts"],
  "sourcesContent": ["import {\n  AnyEqualityComparator,\n  Cache,\n  CircularState,\n  Dictionary,\n  State,\n  TypeEqualityComparator,\n} from './internalTypes';\n\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Combine two comparators into a single comparators.\n */\nexport function combineComparators<Meta>(\n  comparatorA: AnyEqualityComparator<Meta>,\n  comparatorB: AnyEqualityComparator<Meta>,\n) {\n  return function isEqual<A, B>(a: A, b: B, state: State<Meta>) {\n    return comparatorA(a, b, state) && comparatorB(a, b, state);\n  };\n}\n\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nexport function createIsCircular<\n  AreItemsEqual extends TypeEqualityComparator<any, any>,\n>(areItemsEqual: AreItemsEqual): AreItemsEqual {\n  return function isCircular(\n    a: any,\n    b: any,\n    state: CircularState<Cache<any, any>>,\n  ) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, state);\n    }\n\n    const { cache } = state;\n\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n\n    const result = areItemsEqual(a, b, state);\n\n    cache.delete(a);\n    cache.delete(b);\n\n    return result;\n  } as AreItemsEqual;\n}\n\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nexport function getStrictProperties(\n  object: Dictionary,\n): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(\n    getOwnPropertySymbols(object),\n  );\n}\n\n/**\n * Whether the object contains the property passed as an own property.\n */\nexport const hasOwn =\n  Object.hasOwn ||\n  ((object: Dictionary, property: number | string | symbol) =>\n    hasOwnProperty.call(object, property));\n\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nexport function sameValueZeroEqual(a: any, b: any): boolean {\n  return a || b ? a === b : a === b || (a !== a && b !== b);\n}\n", "import { getStrictProperties, hasOwn, sameValueZeroEqual } from './utils';\nimport type {\n  Dictionary,\n  PrimitiveWrapper,\n  State,\n  TypedArray,\n} from './internalTypes';\n\nconst OWNER = '_owner';\n\nconst { getOwnPropertyDescriptor, keys } = Object;\n\n/**\n * Whether the arrays are equal in value.\n */\nexport function areArraysEqual(a: any[], b: any[], state: State<any>) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the dates passed are equal in value.\n */\nexport function areDatesEqual(a: Date, b: Date): boolean {\n  return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n\n/**\n * Whether the `Map`s are equal in value.\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  state: State<any>,\n): boolean {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const matchedIndices: Record<number, true> = {};\n  const aIterable = a.entries();\n\n  let index = 0;\n  let aResult: IteratorResult<[any, any]>;\n  let bResult: IteratorResult<[any, any]>;\n\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.entries();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      const [aKey, aValue] = aResult.value;\n      const [bKey, bValue] = bResult.value;\n\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch =\n          state.equals(aKey, bKey, index, matchIndex, a, b, state) &&\n          state.equals(aValue, bValue, aKey, bKey, a, b, state))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value.\n */\nexport function areObjectsEqual(\n  a: Dictionary,\n  b: Dictionary,\n  state: State<any>,\n): boolean {\n  const properties = keys(a);\n\n  let index = properties.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  let property: string;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (\n      property === OWNER &&\n      (a.$$typeof || b.$$typeof) &&\n      a.$$typeof !== b.$$typeof\n    ) {\n      return false;\n    }\n\n    if (\n      !hasOwn(b, property) ||\n      !state.equals(a[property], b[property], property, property, a, b, state)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nexport function areObjectsEqualStrict(\n  a: Dictionary,\n  b: Dictionary,\n  state: State<any>,\n): boolean {\n  const properties = getStrictProperties(a);\n\n  let index = properties.length;\n\n  if (getStrictProperties(b).length !== index) {\n    return false;\n  }\n\n  let property: string | symbol;\n  let descriptorA: ReturnType<typeof getOwnPropertyDescriptor>;\n  let descriptorB: ReturnType<typeof getOwnPropertyDescriptor>;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (\n      property === OWNER &&\n      (a.$$typeof || b.$$typeof) &&\n      a.$$typeof !== b.$$typeof\n    ) {\n      return false;\n    }\n\n    if (!hasOwn(b, property)) {\n      return false;\n    }\n\n    if (\n      !state.equals(a[property], b[property], property, property, a, b, state)\n    ) {\n      return false;\n    }\n\n    descriptorA = getOwnPropertyDescriptor(a, property);\n    descriptorB = getOwnPropertyDescriptor(b, property);\n\n    if (\n      (descriptorA || descriptorB) &&\n      (!descriptorA ||\n        !descriptorB ||\n        descriptorA.configurable !== descriptorB.configurable ||\n        descriptorA.enumerable !== descriptorB.enumerable ||\n        descriptorA.writable !== descriptorB.writable)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nexport function arePrimitiveWrappersEqual(\n  a: PrimitiveWrapper,\n  b: PrimitiveWrapper,\n): boolean {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n\n/**\n * Whether the regexps passed are equal in value.\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp): boolean {\n  return a.source === b.source && a.flags === b.flags;\n}\n\n/**\n * Whether the `Set`s are equal in value.\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  state: State<any>,\n): boolean {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const matchedIndices: Record<number, true> = {};\n  const aIterable = a.values();\n\n  let aResult: IteratorResult<any>;\n  let bResult: IteratorResult<any>;\n\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.values();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch = state.equals(\n          aResult.value,\n          bResult.value,\n          aResult.value,\n          bResult.value,\n          a,\n          b,\n          state,\n        ))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the TypedArray instances are equal in value.\n */\nexport function areTypedArraysEqual(a: TypedArray, b: TypedArray) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import {\n  areArraysEqual as areArraysEqualDefault,\n  areDatesEqual as areDatesEqualDefault,\n  areMapsEqual as areMapsEqualDefault,\n  areObjectsEqual as areObjectsEqualDefault,\n  areObjectsEqualStrict as areObjectsEqualStrictDefault,\n  arePrimitiveWrappersEqual as arePrimitiveWrappersEqualDefault,\n  areRegExpsEqual as areRegExpsEqualDefault,\n  areSetsEqual as areSetsEqualDefault,\n  areTypedArraysEqual,\n} from './equals';\nimport { combineComparators, createIsCircular } from './utils';\nimport type {\n  ComparatorConfig,\n  CreateState,\n  CustomEqualCreatorOptions,\n  EqualityComparator,\n  InternalEqualityComparator,\n  State,\n} from './internalTypes';\n\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATE_TAG = '[object Date]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\n\nconst { isArray } = Array;\nconst isTypedArray =\n  typeof ArrayBuffer === 'function' && ArrayBuffer.isView\n    ? ArrayBuffer.isView\n    : null;\nconst { assign } = Object;\nconst getTag = Object.prototype.toString.call.bind(\n  Object.prototype.toString,\n) as (a: object) => string;\n\ninterface CreateIsEqualOptions<Meta> {\n  circular: boolean;\n  comparator: EqualityComparator<Meta>;\n  createState: CreateState<Meta> | undefined;\n  equals: InternalEqualityComparator<Meta>;\n  strict: boolean;\n}\n\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nexport function createEqualityComparator<Meta>({\n  areArraysEqual,\n  areDatesEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  arePrimitiveWrappersEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  areTypedArraysEqual,\n}: ComparatorConfig<Meta>): EqualityComparator<Meta> {\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  return function comparator(a: any, b: any, state: State<Meta>): boolean {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n\n    // If the items are not non-nullish objects, then the only possibility\n    // of them being equal but not strictly is if they are both `NaN`. Since\n    // `NaN` is uniquely not equal to itself, we can use self-comparison of\n    // both objects, which is faster than `isNaN()`.\n    if (\n      a == null ||\n      b == null ||\n      typeof a !== 'object' ||\n      typeof b !== 'object'\n    ) {\n      return a !== a && b !== b;\n    }\n\n    const constructor = a.constructor;\n\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n\n    // Constructors should match, otherwise there is potential for false positives\n    // between class and subclass or custom object and POJO.\n    if (constructor !== b.constructor) {\n      return false;\n    }\n\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid capturing the string tag.\n    if (constructor === Object) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n    // the string tag or doing an `instanceof` check.\n    if (isArray(a)) {\n      return areArraysEqual(a, b, state);\n    }\n\n    // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n    // capturing the string tag or comparing against all possible constructors.\n    if (isTypedArray != null && isTypedArray(a)) {\n      return areTypedArraysEqual(a, b, state);\n    }\n\n    // Try to fast-path equality checks for other complex object types in the\n    // same realm to avoid capturing the string tag. Strict equality is used\n    // instead of `instanceof` because it is more performant for the common\n    // use-case. If someone is subclassing a native class, it will be handled\n    // with the string tag comparison.\n\n    if (constructor === Date) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (constructor === RegExp) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (constructor === Map) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (constructor === Set) {\n      return areSetsEqual(a, b, state);\n    }\n\n    // Since this is a custom object, capture the string tag to determing its type.\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n    const tag = getTag(a);\n\n    if (tag === DATE_TAG) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (tag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (tag === MAP_TAG) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (tag === SET_TAG) {\n      return areSetsEqual(a, b, state);\n    }\n\n    if (tag === OBJECT_TAG) {\n      // The exception for value comparison is custom `Promise`-like class instances. These should\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\n      // it reaches this point then that strict equality comparison has already failed.\n      return (\n        typeof a.then !== 'function' &&\n        typeof b.then !== 'function' &&\n        areObjectsEqual(a, b, state)\n      );\n    }\n\n    // If an arguments tag, it should be treated as a standard object.\n    if (tag === ARGUMENTS_TAG) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n      return arePrimitiveWrappersEqual(a, b, state);\n    }\n\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  };\n}\n\n/**\n * Create the configuration object used for building comparators.\n */\nexport function createEqualityComparatorConfig<Meta>({\n  circular,\n  createCustomConfig,\n  strict,\n}: CustomEqualCreatorOptions<Meta>): ComparatorConfig<Meta> {\n  let config = {\n    areArraysEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areArraysEqualDefault,\n    areDatesEqual: areDatesEqualDefault,\n    areMapsEqual: strict\n      ? combineComparators(areMapsEqualDefault, areObjectsEqualStrictDefault)\n      : areMapsEqualDefault,\n    areObjectsEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areObjectsEqualDefault,\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqualDefault,\n    areRegExpsEqual: areRegExpsEqualDefault,\n    areSetsEqual: strict\n      ? combineComparators(areSetsEqualDefault, areObjectsEqualStrictDefault)\n      : areSetsEqualDefault,\n    areTypedArraysEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areTypedArraysEqual,\n  };\n\n  if (createCustomConfig) {\n    config = assign({}, config, createCustomConfig(config));\n  }\n\n  if (circular) {\n    const areArraysEqual = createIsCircular(config.areArraysEqual);\n    const areMapsEqual = createIsCircular(config.areMapsEqual);\n    const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n    const areSetsEqual = createIsCircular(config.areSetsEqual);\n\n    config = assign({}, config, {\n      areArraysEqual,\n      areMapsEqual,\n      areObjectsEqual,\n      areSetsEqual,\n    });\n  }\n\n  return config;\n}\n\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nexport function createInternalEqualityComparator<Meta>(\n  compare: EqualityComparator<Meta>,\n): InternalEqualityComparator<Meta> {\n  return function (\n    a: any,\n    b: any,\n    _indexOrKeyA: any,\n    _indexOrKeyB: any,\n    _parentA: any,\n    _parentB: any,\n    state: State<Meta>,\n  ) {\n    return compare(a, b, state);\n  };\n}\n\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nexport function createIsEqual<Meta>({\n  circular,\n  comparator,\n  createState,\n  equals,\n  strict,\n}: CreateIsEqualOptions<Meta>) {\n  if (createState) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      const { cache = circular ? new WeakMap() : undefined, meta } =\n        createState!();\n\n      return comparator(a, b, {\n        cache,\n        equals,\n        meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  if (circular) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      return comparator(a, b, {\n        cache: new WeakMap(),\n        equals,\n        meta: undefined as Meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  const state = {\n    cache: undefined,\n    equals,\n    meta: undefined,\n    strict,\n  } as State<Meta>;\n\n  return function isEqual<A, B>(a: A, b: B): boolean {\n    return comparator(a, b, state);\n  };\n}\n", "import {\n  createEqualityComparatorConfig,\n  createEqualityComparator,\n  createInternalEqualityComparator,\n  createIsEqual,\n} from './comparator';\nimport type { CustomEqualCreatorOptions } from './internalTypes';\nimport { sameValueZeroEqual } from './utils';\n\nexport { sameValueZeroEqual };\nexport * from './internalTypes';\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nexport const deepEqual = createCustomEqual();\n\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nexport const strictDeepEqual = createCustomEqual({ strict: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nexport const circularDeepEqual = createCustomEqual({ circular: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularDeepEqual = createCustomEqual({\n  circular: true,\n  strict: true,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nexport const shallowEqual = createCustomEqual({\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nexport const strictShallowEqual = createCustomEqual({\n  strict: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nexport const circularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n  strict: true,\n});\n\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nexport function createCustomEqual<Meta = undefined>(\n  options: CustomEqualCreatorOptions<Meta> = {},\n) {\n  const {\n    circular = false,\n    createInternalComparator: createCustomInternalComparator,\n    createState,\n    strict = false,\n  } = options;\n\n  const config = createEqualityComparatorConfig<Meta>(options);\n  const comparator = createEqualityComparator(config);\n  const equals = createCustomInternalComparator\n    ? createCustomInternalComparator(comparator)\n    : createInternalEqualityComparator(comparator);\n\n  return createIsEqual({ circular, comparator, createState, equals, strict });\n}\n"],
  "mappings": "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",
  "names": ["areArraysEqual", "areDatesEqual", "areMapsEqual", "areObjectsEqual", "arePrimitiveWrappersEqual", "areRegExpsEqual", "areSetsEqual", "areTypedArraysEqual", "areObjectsEqualStrictDefault", "areArraysEqualDefault", "areMapsEqualDefault", "areObjectsEqualDefault", "areSetsEqualDefault", "_a"]
}
